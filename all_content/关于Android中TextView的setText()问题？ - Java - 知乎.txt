


关于Android中TextView的setText()问题？ - Java - 知乎






--------------------Link http://www.zhihu.com/question/50088530 ----------------------





--------------------Detail----------------------

当调用TextView.setText(CharSequence text)之后会调用一次TextView.onDraw(Canvas canvas)方法。例如当我点击一次按钮时则调用TextView.setText(CharSequence text)方法给TextView设置文本，此时会调用一次TextView.onDraw(Canvas canvas)。代码如下：这样每次我点击按钮时textView都会调用一次onDraw(Canvas canvas)方法。但是当我使用for循环来多次调用setText(CharSequence text)却不会多次调用onDraw(Canvas canvas)方法。例如这样：或者这样时：都只会调用一次onDraw(Canvas canvas)方法，请问大家为什么会产生这种现象？

-------------------------answer 0 via  -------------------------


在一个循环内或者是连续的调用view.setText()，每一次的调用setText都会触发view的invalidate()函数，然而invalidate()函数并非调用了一次就会立即执行一次绘制操作(参考答案Why isn't view.invalidate immediately redrawing the screen in my android game)，而是需要等UI线程完成了现有的work后才会来执行绘制操作；而三次的invalidate()操作也会被优化成一个命令来完成。=====update刚才查看了一下老罗的博客，里面有讲到:    每一个View都被抽象成了一个RenderNode,而每一个node都关联有一个Display List Renderer。DisplayList是一个绘制命令缓冲区。也就是说，当View的成员函数onDraw被调用时，我们调用通过参数传递进来的Canvas的drawXXX成员函数绘制图形时，我们实际上只是将对应的绘制命令以及参数保存在一个List中。接下来再通过DisplayList Renderer执行这个List中的绘制命令。       引进DisplayList的概念主要是两个好处:第一个好处是在下一帧绘制中，如果一个View的内容不需要更新，那么就不用重建DisplayList，也就是不需要调用它的onDraw成员函数。第二个好处是在下一帧中，如果一个View仅仅是一些简单的属性发生变化，例如位置和text值发生变化，也不需要重建它的DisplayList，只需要在上一次建立的Display List中修改一下对应的属性就可以了，这也意味着不需要调用它的onDraw成员函数。这两个好处使用在绘制应用程序窗口的一帧时，省去很多应用程序代码的执行，也就是大大地节省了CPU的执行时间。链接地址: http://blog.csdn.net/luoshengyang/article/details/45601143


-------------------------answer 1 via  -------------------------


首先你的说法是错的。调用setText并不会直接调用onDraw，调用的是requestLayout。而requestLayout只是给TextView设置了一个标记而已，要等到ViewRootImpl的下一次traversal才会实际对TextView做测量和更新绘制并清除标记，所以你在下一次的traversal前不管做多少次的setText都只会执行一次onDrawPS：有空可以看看源码，很有帮助


-------------------------answer 2 via  -------------------------


消息循环机制，简单抽象如下：Looper 取出 Click 的处理子程序，在主线程执行之；子程序进行一系列操作，包括对 UI 的操作；每次 setText 方法调用都会向消息列队中 post 一个 invalidate 通知，标记一块区域为脏区域；Looper 执行完上述子程序，继续取消息，得到 invalidate 消息，这里是 onDraw 被调用的发源地，onDraw 之后那块区域不是脏区域了，遂后续 onDraw 调用不会产生。


-------------------------answer 3 via  -------------------------


感觉很好理解吧，同一次UI绘制（你写for循环或者手动set3次都算在同一次UI绘制过程中），你给同一个textview对象赋值，只有最后一个会生效，所以只走了最后一个ondraw一次你可以timer写一个延时post到handler，然后再给这个对象settext，应该就是每次都在走ondraw，因为它每次UI绘制不是同一次


-------------------------answer 4 via  -------------------------


谢邀，你试试每次setText时改变文字内容。估计是因为内容一样所以没绘制。==== 更新 ====估计是你太快，刷新赶不上。可能Android控件是被动刷新


-------------------------answer 5 via  -------------------------


setText会引起绘制，每次绘制是需要向Looper发消息的，放到消息队列的尾部。等到轮询到当前消息时才会调用到绘制的方法。如果你发送多个绘制消息，也只是重置绘制的Flag位。而不是立即就执行绘制方法。并且在ViewRootImpl里面，有标志位来判断是否已经有绘制进来，有的话就不会在做处理了。两个例子：1.第二个，第三个setText你放到Handler.post里面去，你看onDraw会执行几次？应该是三次2.在setText之后打印一个Log.(A)，在onDraw里面打印一个Log.(B)，你觉得会先打印哪个？应该是A先打印。update-----------------------------看了上面答案，基本没说到点子上


-------------------------answer 6 via  -------------------------


刷新有个时间间隔吧，16.66ms，你连着输入三次settext，settext 123settext 456settext 789实际上只刷新了最后一个settext 789因为很明显的，你要在主线程调用settext而刷新也即是ondraw也要在主线程里调用所以最终的执行顺序肯定是先执行了3次settext再执行ondraw所以即便调用了3次ondraw，它也不会依次刷新123 456 789 而且只能刷新三次789，因为textview里面在你最后一次settext 789的时候早已把123 456给覆盖了所以，既然如此，android系统它又何必刷新三次789呢，一次不就好了


-------------------------answer 7 via  -------------------------


invalidate这个单词很有意思，它的中文翻译是“使无效”而不是“刷新”，这两个意思几乎是天壤之别。“使无效”是一个被动的过程，只是把view的某个属性改变，比如绘制区域变得dirty。而“刷新”是一个主动过程。 Android view在绘制的时候是一个被动过程，等到消息队列循环到刷新view命令的时候，就去检查那些标志位有没有变化，这一次命令就是一次刷新过程，等下一个16ms再检查一次（刷新一次）。 所以虽然快速设置了三次text，实际只有一次检查（16ms以内）。Google工程师方法名起的真几把好。。。。。


-------------------------answer 8 via  -------------------------


当调用setText时，TextView会判断目标内容是否和已有内容一致，如果一致，则不做任何处理，题主也可以查看源码证实。UPDATE：没有找到明显的与此相关的代码，看来是我想当然了，我开始认为可能和TextInputLayout的addError方法实现得差不多的。
