


Spring，Django，Rails，Express这些框架技术的出现都是为了解决什么问题，现在这些框架都应用在哪些方面？ - Django（框架） - 知乎






--------------------Link http://www.zhihu.com/question/25654738 ----------------------





--------------------Detail----------------------

分别列举了Java，Python，Ruby，Node.js的一些热门框架，初学编程，发现这个世界里有各种各样的编程语言和五花八门的框架技术，我感觉盲目跟风到处去学框架肯定是不好的，而且框架本身也只是一种工具，但是我想请教一下这些五花八门的框架设计出来的初衷到底都是为了解决什么问题？以及现在这些框架各自的优势领域是哪些？具体做的是哪些业务？

-------------------------answer 0 via  -------------------------


归纳题主的问题：这个世界上有各种各样的框架，设计这些五花八门框架的初衷到底是什么？我们该不该学习框架，该如何学习使用这些框架？回答题主的问题：一、首先，到底什么是框架？想要回答这个问题，我们要慢慢来。①首先从DRY原则开始说起Don't Repeat Yourself，不要重复你的代码。DRY原则的重要性怎么提都不过分，很多人说编程是种机械性的工作，而有很多程序员也自嘲为码农，意为编程成了一种没有技术含量的体力性工作。如果不想沦为这个境界，首先需要的就是将DRY原则融入你的血液，在今后的编码工作中加以运用。1）最初级的DRY：语法级别System.out.println(1);
System.out.println(2);
……
System.out.println(10);
我想只要学过基础语法，都会采用下面的形式。for (int i = 1; i <= 10; i++) {
    System.out.println(i);
}
如果发现有任何人采用上面一种形式的编码形式，那么不用怀疑，他对于编程绝对还没有入门。我们当然会选择省力的做法，这种做法不但省力，还会有利于我们后续修改或扩展这组代码，如：for (int i = 1; i <= 10; i++) {
    System.out.println(i * 2 + 1);
}
我们进行这样的修改，只需要修改一处，而上面的形式却需要修改10处，当然会更麻烦且更容易出错，所以请记住能不重复就不重复。2）进阶的DRY原则：方法级别当我们经常写一些重复性代码时，我们就要注意看能否将其抽取出来成为一个方法，如：try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
让我们将其抽取到一个方法 threadSleep() 中，这样我们只需要调用 threadSleep() 就可以实现原来的功能，不但所需敲击的代码更少，而且代码看起来更加清楚明白。而为了增加这个方法的复用性，我们还可以将其中固定的数字抽取成为参数，如：private static void threadSleep(int millis) {
    try {
        Thread.sleep(millis);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
这样我们就可以利用这个方法实现不同时间的sleep了。要注意提高代码的复用性也是实践DRY原则的一个重要方法，在后面我们也可以看到框架为了提高所谓的灵活性进行的一些设计，如在适当的位置增加扩展点。3）继续进阶的DRY原则：类型级别现在我们看一个类public class Person {
    private String name;
    private int age;
    // Setter & Getter ...
}
我们新建一些Person类实例，并进行一些操作：Person person = new Person();
person.setName("jack");
person.setAge(18);
Person person2 = new Person();
person2.setName("rose");
person2.setAge(17);
.....
System.out.printf("Name: %s, Age:%d\n", person.getName(), person.getAge());
System.out.printf("Name: %s, Age:%d\n", person2.getName(), person2.getAge());
.....
观察这些代码，其实有很大的DRY改造空间，首先可以添加一个构造方法public Person(String name, int age) {
    this.name = name;
    this.age = age;
}
其次，可以添加一个toString()方法public String toString() {
    return String.format("Name: %s, Age: %d", name, age);
}
这样的话，上面的代码就可以改成下面的形式。Person person = new Person("jack", 18);
Person person2 = new Person("rose", 17);
......
System.out.println(person.toString());
System.out.println(person2.toString());
......
4）继续继续进阶的DRY原则：多个类组合级别上面的代码我们其实还是有改善空间，就是利用容器类List<Person> list = new ArrayList<>();
list.add(new Person("jack", 18));
list.add(new Person("rose", 17));
......
list.forEach(p -> System.out.println(p));
这里利用JDK8的Stream API以及Lambda表达式输出，其实可以进一步简化为 list.forEach(System.out::println);
这里我们可以看到，基本上我们写代码只写有变化的代码，而尽量不写机械性重复性的代码，其实后面我们就会知道，这就叫专注于业务逻辑，所谓业务逻辑就是你这个项目中，与别的项目都不一样的地方，必须由你亲自去编写实现的部分。其实容器类很大程度上也是为了帮助我们编写代码而被设计出来的，首先让我们不必为每一个对象起名字（省去了person,person2,...等变量），然后又为批量操作提供了可能性。像是这样一系列有用的类组合起来可以称之为类库。常用的类库有Commons-Lang包等，为我们提供了一大批实用方法，我之所以提到类库，也是因为框架其实也是一种特殊的类库，但是却与一般的类库有着本质的不同。②设计模式，更高层级的DRY应用上面我讲到了DRY原则的几个层次，一般情况下大家也早就这样使用了，属于入门之后很容易自己就想到得一些层次。但是设计模式不一样，设计模式是经过长时间编码之后，经过系统性的总结所提出的针对某一类问题的最佳解决方案，又称之为最佳实践。而在小规模的编码工作中，其实并不需要什么设计模式，只有大型程序才有设计模式发挥的空间，所以我们需要借助一些特定领域有足够规模的问题来了解一下设计模式存在的必要性。1）连接数据库，进行一些操作，并安全释放数据库连接。public static boolean updatePassword(String username, String password, String newpassword) {
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    boolean success = false;
    try {
        conn = beginTransaction();
        stmt = conn.prepareStatement("select id, password from user where username = ?");
        stmt.setString(1, username);
        rs = stmt.executeQuery();
        if (rs.next()) {
            if (rs.getString("password").equals(password)) {
                PreparedStatement stmt2 = null;
                try {
                    stmt2 = conn.prepareStatement("update user set password = ? where id = ?");
                    stmt2.setString(1, newpassword);
                    stmt2.setLong(2, rs.getLong("id"));
                    success = stmt2.executeUpdate() > 0;
                } finally {
                    safeClose(stmt2);
                }
            }
        }
        commitTransaction(conn);
        return success;
    } catch (SQLException e) {
        rollbackTransaction(conn);
        throw new RuntimeException(e);
    } finally {
        safeClose(rs);
        safeClose(stmt);
        safeClose(conn);
    }
}
上面是一个简单的数据库事务，虽然只有一个查询和一个更新，但是想要将其继续简化却并不容易，虽然其中有关于业务逻辑的部分只是少量几行代码，但是初始化，异常，提交，回滚操作让我们很难抽取出一个合适的方法来。虽然我们已经抽取出了 begin,commit,rollback,safeClose等方法，但是仍嫌繁琐。我们发现之所以我们难以抽取方法，主要是因为流程，因为里面牵扯到流程控制，而流程控制一般是由我们程序员来控制的，所以也就必然需要我们手动编码来完成。难道真的就不能继续简化了吗？这就是需要设计模式的时候了。2）应用设计模式「模板方法模式」public static boolean updatePassword(String username, String password, String newpassword) {
    return connection(conn -> statement(conn, "select id, password from user where username = ?", stmt -> {
        stmt.setString(1, username);
        return resultSet(stmt, rs -> {
            if (rs.next()) {
                if (rs.getString("password").equals(password)) {
                    long id = rs.getLong("id");
                    return statement(conn, "update user set password = ? where id = ?", stmt2 -> {
                        stmt2.setString(1, newpassword);
                        stmt2.setLong(2, id);
                        return stmt2.executeUpdate() == 1;
                    });
                }
            }
            return false;
        });
    }));
}
可以看到，所有的conn,stmt,rs的开启和关闭，事务的提交和回滚都不用自己手动编写代码进行操作了，之所以可以达到这个效果，就是因为使用了模板方法设计模式，核心就是通过回调方法传递想对资源进行的操作，然后将控制权交给另一个方法，让这个方法掌握流程控制，然后适当的时候回调我们的代码（也就是我们自己写的业务逻辑相关的代码）。这是需要额外写的几个方法public interface ConnectionCallback<T> {
    T doConnection(Connection conn) throws SQLException;
}
public interface StatementCallback<T> {
    T doStatement(PreparedStatement stmt) throws SQLException;
}
public interface ResultSetCallback<T> {
    T doResultSet(ResultSet rs) throws SQLException;
}
public static <T> T connection(ConnectionCallback<T> callback) {
    Connection conn = null;
    T result = null;
    try {
        conn = beginTransaction();
        result = callback.doConnection(conn);
        commitTransaction(conn);
    } catch (SQLException e) {
        rollbackTransaction(conn);
        throw new RuntimeException(e);
    } finally {
        safeClose(conn);
    }
    return result;
}
public static <T> T statement(Connection conn, String sql, StatementCallback<T> callback) throws SQLException {
    PreparedStatement stmt = null;
    T result = null;
    try {
        stmt = conn.prepareStatement(sql);
        result = callback.doStatement(stmt);
    } finally {
        safeClose(stmt);
    }
    return result;
}
public static <T> T resultSet(PreparedStatement stmt, ResultSetCallback<T> callback) throws SQLException {
    ResultSet rs = null;
    T result = null;
    try {
        rs = stmt.executeQuery();
        result = callback.doResultSet(rs);
    } finally {
        safeClose(rs);
    }
    return result;
}
你们可能会疑惑，这些代码加上我们写的业务逻辑的代码，比原来的代码还要长，有什么必要使用这个设计模式。这正是我前面已经指出的一个问题，那就是要你的程序规模足够大才有必要应用设计模式，试想如果你有上百个乃至上千个数据库操作方法需要写，那么是不是写这几个额外的方法，就不算什么了呢。其实这正是DRY原则在更高层次上的应用，即结合设计模式来达到更高层次的代码复用效果，进而应用DRY原则。而想要在这个层次继续向上攀升，那就必须是结合众多设计模式以及一些高层架构设计，能够帮助我们实现这一目的的就是框架。3）框架，是设计模式的集大成者，是DRY原则的最高应用先让我们来看一下，使用框架会是什么样的一种体验？这里以Hibernate + Spring声明式事务为例@Transactional
public boolean updatePassword(String username, String password, String newpassword) {
    User user = (User) session().createQuery("from User where username = :username")
            .setString("username", username)
            .uniqueResult();
    if (user != null && user.getPassword().equals(password)) {
        user.setPassword(newpassword);
        return true;
    }
    return false;
}
可以发现令人惊讶的简洁，而且代码逻辑异常清晰，完全不需要考虑conn,stmt,rs等资源的释放，以及事务的提交和回滚，但是这些事情其实框架已经默默的帮我们做到了。这才叫真正的专注于业务逻辑，尽最大可能的只写与业务逻辑有关的代码。当然这些框架的效果虽然神奇，其实只要细细探究其内部原理，是完全可以理解并掌握的。二、那么问题就来了，框架到底是什么？要不要学，怎么学？上面我说过了，框架其实就是一个或一组特殊的类库，特殊在什么地方？特殊在控制权转移！框架与一般类库不同的地方是，我们调用类库，而框架调用我们。也就是说框架掌握整个程序的控制权，我们必须一定程度上把程序流程的控制权交给框架，这样框架才能更好的帮助我们。下面以JavaWeb开发为例再进行一些说明，并顺便简单介绍一下JavaWeb的一些脉络。①静态网页时代本来网站都是一个个静态HTML组成的，或许这些网页还是用Dreamweaver写的，但是这样的静态页面显然不能满足我们，很快我们就迎来了动态网页的时代。②Servlet时代如果熟悉HTTP协议的话，我们就知道其实访问网页的过程不过是一次TCP连接罢了。浏览器发起TCP连接到服务器，服务器接受请求，然后返回HTML代码作为响应。那么我们完全可以等到接受到请求之后，再动态生成HTML代码返回给客户端。Servlet就是这么做的，其主要代码不过是利用out.write()一点一点的输出HTML代码罢了。当然我们可以在其中掺杂一点动态的东西，如返回当前的时间。out.write("<!DOCTYPE html>\r\n");
out.write("<html>\r\n");
out.write("<head>\r\n");
out.write("<title>Index Page</title>\r\n");
out.write("</head>\r\n");
out.write("<body>\r\n");
out.write("Hello, " + new Date() + "\r\n");
out.write("</body>\r\n");
out.write("</html>\r\n");
③ JSP包打天下的时代纯粹的Servlet很是丑陋，给前端程序员理解和修改这样的代码带来了很多困难。因此JSP技术被发明了出来，原理也不复杂，就是不直接写Servlet，而是先写好JSP文件，再由服务器将JSP文件编译成Servlet。而JSP中是以常见的HTML标签为主，这样前端程序员就能方便的修改这些代码了。<!DOCTYPE html>
<html>
<head>
<title>Index Page</title>
</head>
<body>
Hello, <%=new Date()%>
</body>
</html>
PS：由只使用 Servlet到使用JSP，虽然是一个简单的变化，但这迎合了前后端专业分工的大趋势，让前段人员只需要懂得HTML/CSS/JavaScrip代码就可以开始工作，而不需要学习Servlet那枯燥无味的用法，因此借着JSP技术的东风，JavaWeb技术迅速的扩展开来了。④ Servlet + JSP 时代随着JSP技术的发展，用它写成的网站也越来越大，业务逻辑也越来越复杂。开发人员渐渐发现整个网站渐渐的再次变成了一团乱麻，不仅仅是JSP中夹杂了大量的Java代码，页面之间的耦合关系也越来越紧密。即便是要修改一个简单的按钮文本，或者是引入一段静态的内容，也需要打开越来越庞大的JSP页面，艰难到找到需要修改的部分，有时还不仅仅是一处，这种修改是有很大的风险的，完全有可能引入新的错误。这时候开发者渐渐意识到，仅仅使用JSP是不行的，JSP承担了太多的责任。这时人们又想起了Servlet，Servlet中主要使用Java代码，处理业务逻辑非常轻松。如果JSP只使用HTML代码，而将业务逻辑的代码转移到Servlet中，就可以大大的减轻JSP的负担，并且让前后端分工更加明确。⑤MVC模式时代在Servlet + JSP模式的基础上，Java阵营进一步发展出了一种适合JavaWeb应用的设计模式，MVC设计模式，即将程序分为显示层(Viewer），控制层(Controller)，模型层(Model)。如下图所示：一次典型的访问是这样的流程：一次典型的访问是这样的流程：1. 用户输入网址或点击链接或提交表单，浏览器发起请求2. --> 通过互联网，通过HTTP协议 -->3. Tomcat接受到HTTP请求，生成HttpServletRequest对象，根据Web.xml的配置，调用开发者编写的HttpServlet，HttpServlet根据请求内容，调用JavaBean获取数据，JavaBean从数据库获取数据，返回HttpServlet，HttpServlet将数据转发给JSP，JSP负责将数据渲染为HTML，由Tomcat负责将HTML转化为HTTP响应，返回客户端。4. --> 通过互联网，通过HTTP协议 -->5. 客户端浏览器接收到HTTP响应，浏览器将HTML渲染为页面，并运行其中可能存在的JavaScript进一步调整界面。整个流程必须由开发者精确设计才能运作流畅，其中客户端HTML和JavaScript属于前端设计，服务器运行的其他内容属于后端设计。虽然符合J2EE规范的Tomcat等应用服务器已经帮我们实现了最复杂的一块，即HTTP协议部分，还给我们提供了JSP这个模板引擎，以及自定义标签等手段。但是在控制层，在模型层，J2EE能给我们的帮助少之甚少。就拿用户提交一个表单为例，而我们在Servlet中获取参数为例，虽然不用我们解析HTTP报文，应该已经是要谢天谢地了，但是我们要做的事情仍然很多，分析一下：1. 客户端传过来的数据全是文本，而我们需要的是Java对象。2. 凡是文本就有编码问题，而这需要前后端配合解决。3. 客户端的输入是不可信的，我们必须校验参数的合法性。4. 我们还必须将校验结果反馈给客户，并且最好不要让客户全部重新输入。5. 我们往往不是只有一个参数需要，而是有几个甚至更多参数，要妥善的处理各种情况组合。这些事情几乎全部都需要我们手动编码来完成，几乎每一个 Servlet 都充斥着这样的代码，设置编码，获取参数，校验参数，校验通不过返回错误信息，校验通过则进行业务处理。而更重要的是，获取参数仅仅是整个流程中的一小步，我们的Servlet中存在着大量的重复性，机械性代码，而处理业务逻辑的代码可能只有一两行。⑥JavaWeb框架既然存在着大量的重复，我们当然不能忍，必须请出DRY大法。显然JavaWeb应用是一个规模庞大，流程复杂的应用，我们正需要JavaWeb框架的帮助。以Struts2框架为例，他能给我们什么帮助呢？1. 在控制层，由Struts2的核心控制器接管控制权，将本来在Web.xml进行配置的一些工作，转移到自定义的struts.xml文件中，这个文件的配置形式更友好。2. Struts2封装了Serlvet Api，使用POJO对象作为控制器（Action），大量使用反射，不要求继承特定类，有利于复用及单元测试。提供ActionSupport类，结合struts2标签，能很方面实现的校验信息的收集及反馈。3. 提供国际化支持，在显示层有国际化相关的标签，在控制层由国际化相关的API。提供基于配置的校验及JS生成技术。智能化的参数类型转换，支持自定义转换器。提供Action拦截器，方便实现AOP模式。4. 提供了基于OGNL表达式的数据共享模式，前后端数据交流更简单，提供了Struts2标签库，简单好用，支持多种模板，如FreeMarker，支持各种插件，如JSON，支持整合多种框架，如Spring。总之一句话，能在各方各面给我们强大的帮助。⑦所以当然要学框架，要用框架，那么要怎么学？1. 用框架要知其然，还要知其所以然，要大体明白框架实现一个功能特性的原理，不能只是会用，只是觉得很神奇就可以了。就拿前面的Hibernate + Spring声明式事务为例，要弄明白框架这部分是怎么实现的。2. 首先要夯实你的语言基础，如JavaSE基础，语法掌握，用法掌握，有些同学语法还不熟练就开始学框架，等于地基没打就起高楼，你可能会快一步，但是迟早要遇到瓶颈，甚至摔跟头。3. 那么何时开始学习框架？我不建议新手一开始就直接使用框架。就好像一开始学习编程语言，大家都不推荐直接使用IDE，一定要用命令行自己编译运行几个文件之后，了解清楚了之后才可以使用IDE，要不然对于底层原理不了解，遇到问题没法自己手动排查。4. 使用框架也是一样，如果不是自己写多了重复性的代码，就很难理解框架为什么要这么设计。如果不尝试几种不同的实现，就很难理解框架为了灵活性而做出的设计和扩展点。如果不写几十个权限检查语句，就很难理解AOP到底有什么好处。5. 框架这么好，我该全部使用框架吗？首先只有在规模以上的程序中，才有应用框架的必要，一个简单的程序没必要使用框架，当然如果你很熟练，使用也无所谓。6. 要学习一下框架的核心源代码，要为扩展框架做好准备，因为虽然框架基本上还算灵活，但是面对错综复杂的业务需求，永远不可能面面俱到，而你不了解框架的话，可能会给你实现业务需求造成麻烦。这也是有些人坚持使用Servlet+JSP原生开发，而不是用框架的理由。7. 只要程序大了，归根究底还是要使用框架的，不是用别人写好的，就是自己写一套。这里我不建议自己写，不要重复造轮子，总有专业造轮子的。你草草写就的往往不如别人已经千锤百炼的代码。除非你是为了学习与研究的目的，自己写，那就是一件很好的事情。


-------------------------answer 1 via  -------------------------


先回答题主的问题： 框架的初衷。简言之就是： 抽象出重复，专注于类似，以标准化高质量的代码品质降低广大码农的工作量，拯救IT行业的颈椎，杜绝青光眼，维系夫妻和睦，恋人如胶似漆，单身养肾，下载种子长留。当我们做开发时，绝大部分流程都是相同或者至少类似的，迥异的只不过是我们各个项目的业务逻辑。那么每次我们都要把那些相同的类似的代码敲一遍，或者复制一遍，或者复制后小修一番，这就造成了大部分double work。复制过来的代码又总是多少会有些别扭，质量也是高高低低，命名也是风格多样，子曾经曰过，懒～是人类进步的阶梯！于是乎那些牛到爆懒到家的码农便琢磨着将那些大家都会重复的过程搞出来，然后进行标准化，有个高大上的名词叫“抽象”，然后要对这个被抽象出来的东西起个名字吧？如何做到名称白富美还能接地气呢？码农嘛，纯朴的民工！联想到跟自己建房子时候差不太多呀，这里承重墙，那里抠个OO，下面打个XX，各家房子框架都这样啊，不同的是这里你刷个白漆，那里你挂个陀思妥耶夫思密达sir，对吧？那好吧，我们也叫～～～框架这里就实现了标准化和流水线分工对不对？写框架的专注于框架，越来越稳定性能越来越强悍；妹纸专注于给房子化妆，整了个洋名儿：UI（有爱）或者UEX（无前任），部门名取决于妹纸是否专注于失恋；大老爷们儿还是负责搬砖，这里抽油烟机，那里抽水马桶，美其名曰射机湿，你会发现以前装马桶要长宽高，要糊水泥，有时候还要配个皮揣子，尼玛，有够闹心不？现在你只需要写马桶，然后马桶就通了，源代码里甚至还有TOTO字样，有木有，太方便了，妈妈再也不用担心我熬夜设计马桶了，速度，质量，舒适度，只需3分钟，通通ISO9001，通通通～～～这里，你应该发现了框架的优势与弱势：1）框架的初心是抽象出那些重复度高的代码，言外之意就是如果你的项目足够简单，简单到裸着写都没有什么重复代码，那么你就不需要框架。框架是用来建房子的，铺个草坪要毛框架啊？？？框架是“牛刀”，杀只鸡要毛牛刀啊？有木有？  【框架有其自身的适用场景，是瑞士军刀，非妇孺皆宜】2）一旦你使用了框架，那么你这个项目里面有相当一部分的代码质量是稳定健壮的，比自己写的代码好太多了，我们也不好意思让那么烂的代码伴随框架，所以要多花点时间锤炼自己的代码，与框架同行。 【框架可以让你在保证代码质量的基础上，拥有更多时间来关注自身的业务逻辑与代码】3）自己建的房子松松垮垮，但手熟；别人建的房子坚固，但是不熟悉，你需要有个熟悉的过程，所谓学习曲线就是它了，使用框架，这是无数人，啊，应该是无数牛人智慧的凝聚，理解牛人的思维，怪癖都是一种修炼，需要时间，需要耐心。 【框架有学习曲线，有时候，框架学习的难度比手写代码自己实现的难度要高不少】------------------------再来回答题主的另外一个问题： 框架各自的优势：你应该去各个框架的官网仔细研究它的readme，而不是在这里发问，各个框架都有无数大V的blog有深浅皆宜的使用，请围观。切记，玉和兄长不可兼得。如果追求开发速度快，ROR如果追求方便Full Stack， Django如果追求学习简单上手， PHP框架任选如果直接瞄准FB，TB，BAT，追求性能至上，大团队开发，企业铂金镶钻级开发，Java框架任选------------------------最后回答题主的另外一个问题：框架具体做哪些业务？框架的业务，喔，就是做框架啊，还能有什么呢？至于区别嘛，你说说万科，招商地产，保利，绿地他们造的框架有什么区别？这就涉及到题主最开始的一句话了，如何学习？我的建议是：初学者，不要学习任何框架，裸写，一定要裸写.不裸写几万行代码，你怎么知道哪些代码是重复的？不把Ctrl + C/V摁到掉漆,你怎么能感同身受那些框架射机湿不是吃饱了撑着?裸写代码不被Bug折腾到头发掉了一地,你怎么能理解代码健壮性的可贵?裸写代码不被别人SQL注入拖库,你怎么会感谢Django的ORM?网页不慢到吃顿火锅才能打开你怎么忆起Tornado非阻塞的柔情似水?不裸写代码到颈椎痛,腰椎间盘突出,800度近视,夫妻分床,恋人冷战,BT硬盘坏道,苍老师隐退,你怎么能直接用框架,你怎么好意思叫程序猿?


-------------------------answer 2 via  -------------------------


框架是在人们对组件技术失望之后出现的，"do one thing and do it best" 和 "封装隐藏复杂度" 在项目里往往并不能如意，解开的耦合最终还是要集成，而复杂度更多隐藏在组件与组件的集成，不在单个组件本身，像讲复杂系统的书里经常提到的一句话是 "整体大于部分之和"，给我们小汽车的所有组件但我们组装不出小汽车。框架做的事情，就是自带胶水，做一些脏活累活替我们集成这些组件，降低偶发复杂度，我们可以专心往里面填业务。


-------------------------answer 3 via  -------------------------


推荐你先看一下Wikipedia上的Software framework。里面提到Framework和普通库的几点区别里，我认为最重要的一点是inversion of control。Framework有一点像“凡客体”，“写作者”只需要把相应的词填进去即可。规定了开发者写哪些代码／不写哪些代码，怎么写代码——这就是框架主要解决的问题。如果要说具体解决哪些问题，不同的框架不一样，可以参考Comparison of web application frameworks。Web开发框架里我用过Django、Express、Ember（CakePHP和Rails只是几年前做过小的试验项目，就不说了）。Django是功能很齐全的框架，测试框架、邮件、表单验证、缓存、甚至输出PDF，做网站大多数用到的功能都包含了，它考虑到的各种Scenarios相当细致，奉行的Battery included原则不是吹的。Django社区也很活跃，有许多好用的app、扩展，比如south（Django 1.7 已经集成db migration）、django-reversion、celery、django-cms、easy-thumbnails、django-rest-framework，再加上丰富的Python资源，极大地减轻开发负担。如果你想试验一些API，可以用Django的Console（Rails等也有相同的功能）。如果你想定期或不定期地执行一些任务，比如清除过期的API tokens、批量添加用户，可以写管理脚本。Django的文档也很好，使用内置的东西和自己扩展都很方便。Express是轻量的框架，只提供最基本的功能，当然同样有很多扩展可以用。Node平台吸引我的是Yeoman这样的工具，跟Rails和Django比，在自动化各种mundane tasks上进了一大步。当然也可以将Grunt引入Django项目，不过不是一站式的体验了。Jade模版写起来也很舒服。Express也有很多库可以解决它没解决的问题，比如Django自带的reverse url功能，在Express里可以用web-napopa/node-reversable-router · GitHub 代替。这回倒是轮到Express没有提供“一站式体验”了。现在不少人始倾向于用RESTful API ＋ 前端MVC框架了。前端MVC框架可以提供类似桌面应用的体验。推荐看看Ember。


-------------------------answer 4 via  -------------------------


提高开发效率，所有的web框架基本都类似


-------------------------answer 5 via  -------------------------


低耦合，高內聚，提效率。


-------------------------answer 6 via  -------------------------


Don't Repeat Yourself框架基本就是MVC，最大的不同就是语言不同，但是事实上内里也有太多的不同SSH上面有人说过了PHP做小东西快得很呢，因为他其实相当于一门语言+1个模板引擎。但是做大项目就不行了，各种重复自我，于是php在学其他语言，从语法到框架，一直在学，框架林立，但是php没有deamon，所以还是有局限性的。Python也是框架林立，Django是其中一个全栈框架，优点是python这个语言前后通吃，学一门语言什么都可以做，后端库非常多。缺点是做web没有Rails强Ruby on Rails是DHH觉得php难用，试过很多语言发现表现力都不行，最后碰到ruby一发不可收拾，写了个框架就是Rails。 优点是“web开发最佳实践”，生产力嗷嗷高，缺点是对智商有要求，“勤能补拙”不太适用，很短的一段代码看不懂的时候，挫败感很强。Express是基于node.js开发的一个框架，我认为意义不大，Node.js强在异步，而MVC框架主要是处理业务逻辑的，复杂业务逻辑同步的居多。


-------------------------answer 7 via  -------------------------


为什么有框架。其实Django官方文档第一章：介紹Django中给出了很浅白的答案。如果你曾编写过网络应用程序，流程可能是这样的：从头开始编写网络应用程序。从头编写另一个网络应用程序。3. 从第一步中总结（找出其中通用的代码），并运用在第二步中。4. 重构代码使得能在第 2 个程序中使用第 1 个程序中的通用代码。5. 重复 2-4 步骤若干次。6. 意识到你发明了一个框架。我们举个切实的例子：如下示例，用Python CGI脚本显示数据库中最新出版的10本书： 不用关心语法细节；仅仅感觉一下基本实现的方法：#!/usr/bin/env python

import MySQLdb

print "Content-Type: text/html\n"
print "<html><head><title>Books</title></head>"
print "<body>"
print "<h1>Books</h1>"
print "<ul>"

connection = MySQLdb.connect(user='me', passwd='letmein', db='my_db')
cursor = connection.cursor()
cursor.execute("SELECT name FROM books ORDER BY pub_date DESC LIMIT 10")

for row in cursor.fetchall():
    print "<li>%s</li>" % row[0]

print "</ul>"
print "</body></html>"

connection.close()
首先，用户请求CGI，脚本代码打印Content-Type行，后面跟着换行。 再接下 来是一些HTML的起始标签，然后连接数据库并执行一些查询操作，获取最新的十本书。 在遍历这些书的同时，生成一个书名的HTML列表项。 最后，输出HTML的结束标签并且关闭数据库连接。像这样的一次性的动态页面，从头写起的方法并非一定不好。 其中一点： 这些代码简单易懂，就算是一个初起步的 开发者都能读明白这16行的Python的代码，而且这些代码从头到尾做了什么都能了解得一清二楚。 不需要学习额外 的背景知识，没有额外的代码需要去了解。 同样，也易于部署这16行代码，只需要将它保存为一个latestbooks.cgi 的 文件，上传到网络服务器上，通过浏览器访问即可。尽管实现很简单，还是暴露了一些问题和不便的地方。 问你自己这几个问题：1. 应用中有多处需要连接数据库会怎样呢？ 每个独立的CGI脚本，不应该重复写数据库连接的代码。 比较实用的办法是写一个共享函数，可被多个代码调用。2. 一个开发人员 确实 需要去关注如何输出Content-Type以及完成所有操作后去关闭数据 库么？ 此类问题只会降低开发人员的工作效率，增加犯错误的几率。 那些初始化和释放 相关的工作应该交给一些通用的框架来完成。3. 如果这样的代码被重用到一个复合的环境中会发生什么？ 每个页面都分别对应独立的数据库和密码吗？4. 如果一个Web设计师，完全没有Python开发经验，但是又需要重新设计页面的话，又将 发生什么呢？ 一个字符写错了，可能导致整个应用崩溃。 理想的情况是，页面显示的逻辑与从数据库中读取书本记录分隔开，这样 Web设计师的重新设计不会影响到之前的业务逻辑。以上正是Web框架致力于解决的问题。 Web框架为应用程序提供了一套程序框架， 给你定了一些被验证过的、前人总结出来的好的模式，并提供了一些帮助工具。这样你可以专注于编写清晰、易维护的代码，而无需从头做起，也不会走岔走偏，不要太开心额。


-------------------------answer 8 via  -------------------------


什么ssh,orm,spring,struct，复杂，速度慢，最后把自已框进去了。如果有有一百万种框架学一百万年后，知道了那个最好，再开发？java占语言榜第一，全世界实际各个公司框架加在一起超过了一百万种。答案是否定的，因为人的精力是有限的。软件开发中复杂不会消失，用多种框架，复杂因会从代码跑到xml，更加复杂。与其用各类多如牛毛的框架，多如牛毛的配置，不如用好jsp。一，可视化是关键为什么用jsp，当然是有原因的，一是ide支持，各个java ide都支持jsp，包括dreamwaver，好排版。你用各个标签ide不支持或支持有限，相当于用cgi拼文本来开发。二、热更新jsp和php类似支持热布置，各类标签，标注，模块，都是在走邪路，你要再开发一套支持它的ide或web排版工具，这不是捡了芝麻丢了西瓜。你再开发类似jsp的热更新，你又在重复造轮子。三、jquery+ajax+json淘汰了mvc没有ajax时，html标签和js，和jsp混在一起，但有了json，view层（html+jquery）通过json和c层（类似servlet，无html的jsp）通信，这样，在服务器实际mvc没有任何意义。四、动态语言淘汰了spring什么aop,ioc，各种概念无非是实际了动态化加载，关键用的xml丑陋无比。其实软件需要动态性时我只要加入动态语言如groovy,beanshell,jtyhon，如beanshell(才200kb)，你玩各种概念时，我已经用动态语言+代码生成器实现业务逻辑，早就好了，而且动态性没有我的高，我可以放入数据库中，web中做到真正的动态。五、代码生成器淘汰了orm第一次用orm时感觉很oop，但现在感觉orm是为了oop而oop，性能低下会导致你的网站没有可伸缩性，12306初期慢一部分归功于orm。不要忘了jdbc，其实这些orm代码我可以用代码生成器从jdbc生成orm，比各类orm性能高得多。这样构建系统就不用ssh了。显示层：jsp+jquery(json)+jsp.service=jsp做排版html+另一个jsp做排版json提供接口jsp(只返回json)调用逻辑层。逻辑层：groovy+java，必要时groovy的dsl也可以用上数据访问层：代码生成器，生成类似orm，主要是灵活，性能高，方便。这样的快速开发，业务逻辑用groovy vs java+代码生成器的jdbc+jsp（也可用代码生成器生成部分），性能比ssh高得多，开发速度也快得多


-------------------------answer 9 via  -------------------------


规范代码布局，约束实现方式。我hate所有框架，我是组件党。
