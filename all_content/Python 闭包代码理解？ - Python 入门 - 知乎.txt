


Python 闭包代码理解？ - Python 入门 - 知乎






--------------------Link http://www.zhihu.com/question/31792789 ----------------------





--------------------Detail----------------------

def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
#这段代码的流程能叙述下吗，刚接触，有点晕


-------------------------answer 0 via  -------------------------


调用count执行完，i已经是3了，def f()中的代码并没有执行，后期再调用f1() f2() f3()，结果就是9了啊。


-------------------------answer 1 via  -------------------------


def count():
    fs = []
    for i in range(1, 4):
        def f(j=i):
            return j * j
        fs.append(f)
    return fs

f1, f2, f3 = count()
print(f1(), f2(), f3())
这是你需要的，结果 [1, 4, 9]
或者就用别的答案提到的 lambda。


-------------------------answer 2 via  -------------------------


请看黄哥漫谈Python 闭包。黄哥漫谈Python 闭包。 - 通过python学会编程 - 知乎专栏


-------------------------answer 3 via  -------------------------


#!/usr/bin/env python
#coding:utf-8

def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
print f1(), f2() ,f3()

print f1.__closure__[0].cell_contents # 打印闭包值 即i的值 =3

def count():
    fs = []
    for i in range(1, 4):
        def f(j=i):
             return j*j
        fs.append(f)
    return fs



f1, f2, f3 = count()
print f1(), f2() ,f3()

print f1.__closure__  # 没有闭包，因为外部便利i已经传值给默认参数j了
我对闭包的理解，1 当函数存在嵌套，并且子函数引用了父函数中的变量，可以访问这些变量的作用域就形成闭包。2 如果子函数没有访问父函数中的变量，就不存在闭包。打个比方:一个大盒子，内部有一个小盒子，小盒子里用到一些东西是来自这个大盒子，那么这些来自大盒子的东西，就是闭包。回到例子：第一种形式中，i并没有在函数中定义，所以f 和外部i 构成闭包，i在range最后取值为3，因此在return fs 这一行的时候，这个闭包里i 的值确定了，每一次调用的结果都是9第二种形式，i每个阶段的值，通过默认参数传入j，这时候相当于j拿下了这个接力棒，把中间值都保存下来了，这时候每一个f的构成，没有任何闭包，return之后i就销毁了题主你体会一下这两种形式的不同。如果你不用闭包来定义：f1, f2, f3 =  [lambda :i*i for i in range(1,4)]
print i
print f1(), f2() ,f3()
i = 5
print f1(), f2() ,f3() 
这里所有的匿名函数，都会直接读取全局变量i，因此全局变量i的值，结果也会跟着变。给一个接力棒：f1, f2, f3 =  [lambda j=i:j*j for i in range(1,4)]
print i
print f1(), f2() ,f3()
i = 5
print f1(), f2() ,f3()



-------------------------answer 4 via  -------------------------


闭包简单来说就是 函数+上下文环境。它能捕获函数外部的变量，持有变量所在环境的一个引用，或者说指针。 我对python不熟，不清楚它的具体闭包实现是怎么样的，看@胡子的答案，应该就是把上下文环境保存在＿closure＿里，我有空查查资料。 这个例子的流程的话，就是fs里放了三个闭包，它们都持有对count()的引用（就是＿closure＿吧），所以count()不会被销毁。三个闭包被分别赋值给f1,f2,f3。当你调用f1（）,f2（）,f3（）的时候它们都会到count中去找i，count（）之前已经执行完了，i的值为3，所以结果都为9。


-------------------------answer 5 via  -------------------------


1，python里面所有都是对象，函数也是，你把闭包函数当成一个变量对象来理解，就很清楚了2，和其他普通对象比如字符串，数字的区别在于，这个闭包函数对象是callable的，而且call的过程中还能引用“外面”的变量，比如题目例子中的i3，之所以2种“外面”两个字加引号，是因为看起来是外面，实际不是外面，他们都在一个命名空间，你随便声明一个a=1，再看locals()里面肯定有a在里面


-------------------------answer 6 via  -------------------------


刚才又仔细看了下代码，有点感悟。如果print(f1(),f2(),f3())的话应该是9,9,9首先要明确一点，变量都是引用的内存的一个对象（自己的理解，不对请指出）当程序进入循环，按道理说应该是返回1,4,9这样一个东西但是，我们返回的是函数，且这个函数在返回时并没有执行，这就意味着i变量指向内存里的那个对象已经为3了，我们再次PRINT的时候，函数才执行得出结果，计算过程里i都为3，所以结果应该为9,9,9


-------------------------answer 7 via  -------------------------


虽然这问题时效性可能过了。我觉得根本没有啥闭包那么高深def count():    fs = []    for i in range(1, 4):        def f():             return i*i        fs.append(f())    return fsf1 = count()print(f1[0],f1[1],f1[2])1 4 9fs.append(f)------>fs.append(f())题主给出的例子，返回的是函数的地址，没有执行。然后输出的时候再调用执行f这个函数，这个时候i已经是3了，所以结果是999。改了之后，返回的是函数的值，让他在count时就把值算出来，就是1 4 9 了愿对后来的小白有些帮助


-------------------------answer 8 via  -------------------------


《Learning Python 5th Edition》 Page 506， 小节 Loop variables may require defaults, not scopes详细分析了原理，想要深入理解的话最好把Chapter 17 Scope这一章啃下来，绝对一劳永逸。


-------------------------answer 9 via  -------------------------


刚刚学了闭包，就算是借题目小结一下吧。前提：在Python中，函数也是一级对象，也就是：函数可以被变量赋值，也可以作为另一个函数的            参数；闭包：内层函数调用了外层函数的变量，只有当外层函数被执行完内层函数被调用时，才会进行计算，因此，当f1()调用内层函数时，开始计算i*i，此时i寻找与它连接的外层函数中的变量，即3，所以均返回9
