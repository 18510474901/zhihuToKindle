


求解一道网易游戏的面试题？ - 数学 - 知乎






--------------------Link http://www.zhihu.com/question/36348611 ----------------------





--------------------Detail----------------------

一条直线上有N个小球，每个小球的初始位置，运动方向和运动速度均已知（不同的小球速度不一样），任意两个小球相遇后就都消失。请问，如何找出最后剩下的小球？

-------------------------answer 0 via  -------------------------


2016.9.23补充：我是假设题主面试的是策划岗位，才做出以下回答，如果你面的是程序或者QA什么的可以不用往下看了。--------------------------------------------------------------------------------------------------------------------这是一道面试题，不是在帮学妹写作业，你要做的是展示自己分析问题和解决问题的能力。关于分析问题，你应该尽快发现这个问题的不完备之处，第一时间询问面试官：1、如果3个小球同时碰撞怎么办？2、如果最后剩下多个小球永不碰撞怎么办？一般情况下面试官会告诉你不考虑这两种情况，然后你再开始解决这个问题关于解决问题，重申这不是在帮学妹写作业，能不能算出具体答案不要紧，给出一个直观、可实现的算法才是你要做的事，计算量不是你要考虑的问题。1、首先，假设碰撞后不消失继续行进，那么碰撞时间=距离差/速度差（速度的正负号表示方向）。此时，你需要pia一个N*N的表格给面试官，把任意两个小球碰撞需要的时间告诉面试官，反向运动的小球用正无穷表示碰撞时间。2、然后把这个表里最小的数字找出来，也就是第一对小球碰撞消除需要的时间，然后删除这两个小球所在行列。以上图为例，最小数字就是球2和球3碰撞的时间12，然后把球2和球3所在行列删掉。3、对剩下的数字重复步骤2，直到只剩1个小球。再次强调，这是一道面试题，有笔纸的话，阐述上面这个答案最多1分钟，但如果是笔试题的话，以我对猪厂笔试题的了解，这么做你拿不到满分。------------------------------------------------------------------------------------------------------------------数字是随机出来的，数字不合理的地方请忽略，那只是一个栗子。------------------------------------------------------------------------------------------------------------------多谢家飞猫在评论中的提醒，可以不只剩两个球，答案中已修改。


-------------------------answer 1 via  -------------------------


2015.10.21更新。因为看到评论中对优先队列和实现有疑问，还是改一下吧。一些极端和特殊情况（比如多球同时碰撞、若干组球分别同时碰撞、终止时可能剩下任意个球）其它回答已经说了。具体实现中遇到的问题可以参考讨论。想的跟@非常反感 的回答差不多，再详细一点：注意到每次碰撞只能是相邻的小球，所以需要计算每组相邻小球的碰撞时间，建立一个优先队列（Priority queue）来维护这些碰撞时间数据。每次从优先队列中选取最小的碰撞时间，对应的两个小球就应该最先消失，而且他们的消失只会最多影响到其他的三个碰撞时间数据（其中一个是新增的另两个是要删去的），维护对应优先队列中的这三个数据，重复这一过程直到结束。关于算法复杂度：每次维护会消失两个小球，所以最多需要3n/2次优先队列操作，而每个优先队列操作（包括插入和删除元素）的复杂度可以做到O(lgn)（用二项堆Binomial heap 实现的话），所以整体复杂度是O(nlgn)。感觉不太可能有线性复杂度的算法嘛。


-------------------------answer 2 via  -------------------------


先写一个函数，求出给定N个小球中，最先发生碰撞的两个相邻小球ＩＤ，代码如下：struct Sphere
{
    float pos;
    float speed;
};

// 返回碰撞小球的ID,(-1表示无碰撞)
// pSpheres必需按pos从小到大排序
unsigned int CalculateCollide(const Sphere* pSpheres, unsigned int numSphere)
{
    if (pSpheres == NULL || numSphere < 2)
    {
        return -1;
    }

    float time = FLT_MAX;
    unsigned int index = -1;
    for (unsigned int i = 0; i < numSphere - 1; i++)
    {
        float speed = pSpheres[i].speed - pSpheres[i + 1].speed;
        if (speed < 0.0f)
        {
            continue;
        }
        float dis = pSpheres[i + 1].pos - pSpheres[i].pos;
        float t = dis/speed;
        if (t < time)
        {
            index = i;
            time = t;
        }
    }

    return index;
}
找到后，可以将这两个小球的数据从数组中删除，得到Ｎ－２个小球的数组．继续调用函数CalculateCollide，每次调用会减少两个小球，直到CalculateCollide返回-1为止．顺便说一下，最后剩下的小球不一定是1，可以是(0～Ｎ)之间的任意数．


-------------------------answer 3 via  -------------------------


建立一个有n+1个小球的数组，定义任意小球和最后一个额外小球n所在位置p的碰撞时间为max_double，任意两个实际存在的不可能碰撞的小球的碰撞时间为max_double/2，对小球按位置排序建立优先队列，存储相邻id对，用上面定义的函数作为优先队列的比较函数，按照碰撞时间增序排列取出堆顶对并作为可能结果存储，把对应小球的位置都改为p，然后重整堆如果新堆顶时间是max_double/2，表示当前小球对是剩下的若干个球中的两个；如果新堆顶时间是max_double，表示当前小球对是仅剩的一个或两个球；否则还没有达到最终状态，把这两个球消去之后的新的一对id加入优先队列，重整堆因为最多碰撞n/2次，所以堆的大小最多是3n/2（因为并没有实际删除），时间复杂度仍然是nlogn


-------------------------answer 4 via  -------------------------


我来说个笨办法：假设五个球O O O O O假设速度：->  ->  <-  <-  ->检测每一个球和前后相碰的最小时间，譬如：5 2 2 4 无穷找到最小值的两个球，并把这两个去掉：5 -1 -1 4 无穷   （-1 为flag，后续处理直接忽略）更新去掉两球的的前后两球的时间：8 -1 -1 8 无穷找最小，再去掉-1 -1 -1 -1 无穷只剩下最后一个球啦（肯定无穷的啦）


-------------------------answer 5 via  -------------------------


用线段树？


-------------------------answer 6 via  -------------------------


1，球的位置，状态信息。 2.搜索相邻两个球之间的碰撞时间，取最小时间，不能碰撞去无穷大。3.根据最小时间改变所有球的状态。4，重复2，直到无穷大或者剩下一个球


-------------------------answer 7 via  -------------------------


此题目的是执行效率和代码简洁。 第一步，以小球位置排序第二步，依次计算相邻两个小球时间距离S/v，储存此距离和小球id，推入数组，并排序。（注意不是任意两个，这样计算量保持在1个数量级内。）每个距离对保留原id引用。第三步：距离最短对删除，也就是队列最前端。查找，（应该是索引）受影响的距离对，（位置顺序相邻两个id所在距离对）重新计算距离，加入排序队列。 最终这个数组保留的就是答案了。


-------------------------answer 8 via  -------------------------


问题本质更像一个排序问题。 数组中每个位置放着不同大小的数字N个稳定状态： 0到N-1的数字大小从小往大排列，这个时候剩下的N个球，因为后面一个永远也追不上前面一个。不稳定状态：乱序。 但是最后会趋于稳定状态。 后面大的数会吃掉前面小的数。 这里还要看二者的距离与速度差。


-------------------------answer 9 via  -------------------------


先建立数学模型。在一条直线上，也就是说是一维的，假设所有小球在一个坐标系上，最左边小球坐标为坐标原点，向左运动标志为负，向右运动标志为正。用数学可以表述出所有的小球的坐标位置、方向和速度，将速度常量乘以时间参数X。当X不断增大，多个小球坐标相同时即为相撞，在模型中去除相撞小球。观察剩余小球速度方向，判断是否有相撞可能。若有可能则继续，否则抛出结果。-----------------------------------上面模型有几个问题。首先，在数学角度会存在多个小球无限靠近但不相碰撞，需要对碰撞条件做优化。其次，若X自增，在不同的时间增量中多个小球的碰撞顺序会有所不同，需要对碰撞条件做优化。
